---
# Remediate Role - Main Task Dispatcher
# Supports map-driven remediation for CAT I, CAT II, and CAT III
# All categories now use the scan_driven_*_remediation.yml pattern with remediation maps
# Maps are loaded from win2019_stig/defaults/ or win2022_stig/defaults/

# ============================================================================
# Determine remediation mode
# ============================================================================
- name: Determine remediation mode
  ansible.builtin.set_fact:
    remediation_mode: >-
      {%- if trigger_source | default('manual') == 'eda' and category | default('') != '' -%}
        eda
      {%- elif failed_cat1_controls | default([]) | length > 0 -%}
        scan_driven
      {%- else -%}
        none
      {%- endif -%}

- name: Display remediation mode
  ansible.builtin.debug:
    msg: |
      Remediation Mode: {{ remediation_mode }}
      Trigger Source: {{ trigger_source | default('manual') }}
      Category: {{ category | default('not set') }}
      Failed Control IDs: {{ failed_control_ids | default([]) | length }}
      Failed CAT1 Controls: {{ failed_cat1_controls | default([]) | length }}

# ============================================================================
# EDA-Triggered Remediation
# ============================================================================
- name: Check auto-remediation toggle for EDA mode
  when: remediation_mode == 'eda'
  block:
    - name: Check if auto-remediation is enabled for this category
      ansible.builtin.set_fact:
        auto_remediate_enabled: >-
          {%- if category == 'CAT1' -%}
            {{ auto_remediate_cat1 | default(false) | bool }}
          {%- elif category == 'CAT2' -%}
            {{ auto_remediate_cat2 | default(false) | bool }}
          {%- elif category == 'CAT3' -%}
            {{ auto_remediate_cat3 | default(false) | bool }}
          {%- else -%}
            false
          {%- endif -%}

    - name: Skip remediation - auto-remediation disabled
      when: not auto_remediate_enabled | bool
      ansible.builtin.debug:
        msg: |
          Auto-remediation is DISABLED for {{ category }}.
          To enable, set auto_remediate_{{ category | lower }} = true in EDA activation.
          Failed controls that would be remediated: {{ failed_control_ids | default([]) | join(', ') }}

    - name: Set controls to remediate for EDA mode
      when: auto_remediate_enabled | bool
      ansible.builtin.set_fact:
        controls_to_remediate: "{{ failed_control_ids | default([]) }}"
        remediation_category: "{{ category }}"

- name: Validate scan-driven configuration
  when: remediation_mode == 'scan_driven'
  ansible.builtin.set_fact:
    controls_to_remediate: "{{ failed_cat1_controls }}"
    remediation_category: "CAT1"
    auto_remediate_enabled: true

- name: Skip - no remediation needed
  when: remediation_mode == 'none'
  ansible.builtin.debug:
    msg: "No remediation needed - no failed controls provided"

- name: End play if no remediation to perform
  when: remediation_mode == 'none' or (remediation_mode == 'eda' and not auto_remediate_enabled | default(false) | bool)
  ansible.builtin.meta: end_play

- name: Gather Windows facts
  ansible.windows.win_powershell:
    script: |
      $os = Get-CimInstance Win32_OperatingSystem
      @{
        Caption = $os.Caption
        Version = $os.Version
        BuildNumber = $os.BuildNumber
      } | ConvertTo-Json -Compress
  register: os_info_raw

- name: Parse OS information
  ansible.builtin.set_fact:
    # win_powershell.output is a list, join it to get the JSON string
    os_info: "{{ (os_info_raw.output | join('')) | from_json }}"

- name: Determine Windows version
  ansible.builtin.set_fact:
    windows_version: >-
      {%- if '2022' in os_info.Caption -%}
        2022
      {%- elif '2019' in os_info.Caption -%}
        2019
      {%- else -%}
        unknown
      {%- endif -%}

- name: Create system restore point
  when: remediation.create_restore_point | default(true) and not dry_run
  ansible.windows.win_powershell:
    script: |
      Checkpoint-Computer -Description "Pre-Compliance-Remediation-{{ ansible_date_time.iso8601 }}" -RestorePointType MODIFY_SETTINGS
  ignore_errors: true

- name: Log remediation start
  ansible.builtin.set_fact:
    remediation_start_time: "{{ ansible_date_time.iso8601 }}"

# ============================================================================
# Apply remediation based on category and OS version
# ============================================================================
- name: Fail if OS not supported
  when: windows_version == 'unknown'
  ansible.builtin.fail:
    msg: "Unsupported Windows version: {{ os_info.Caption }}. Only Windows Server 2019/2022 are supported."

- name: Display remediation plan
  ansible.builtin.debug:
    msg: |
      Remediation Plan:
      - OS Version: Windows Server {{ windows_version }}
      - Category: {{ remediation_category }}
      - Controls to remediate: {{ controls_to_remediate | length }}
      - Control IDs: {{ controls_to_remediate | join(', ') }}

# Windows Server 2019 Remediation
# Note: Feature flag (use_external_stig_role) does NOT affect Windows 2019 - always uses existing role
- name: Log feature flag ignored for Windows 2019
  when:
    - windows_version == '2019'
    - use_external_stig_role | default(false) | bool
    - controls_to_remediate | length > 0
  ansible.builtin.debug:
    msg: |
      NOTE: use_external_stig_role is enabled, but Windows 2019 always uses existing win2019_stig role.
      The external role integration is only available for Windows Server 2022.

- name: Apply Windows 2019 CAT I remediation
  when:
    - windows_version == '2019'
    - remediation_category == 'CAT1'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2019_stig/tasks/scan_driven_remediation.yml"
  vars:
    failed_cat1_controls: "{{ controls_to_remediate }}"

- name: Apply Windows 2019 CAT II remediation (map-driven)
  when:
    - windows_version == '2019'
    - remediation_category == 'CAT2'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2019_stig/tasks/scan_driven_cat2_remediation.yml"
  vars:
    failed_cat2_controls: "{{ controls_to_remediate }}"

- name: Apply Windows 2019 CAT III remediation (map-driven)
  when:
    - windows_version == '2019'
    - remediation_category == 'CAT3'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2019_stig/tasks/scan_driven_cat3_remediation.yml"
  vars:
    failed_cat3_controls: "{{ controls_to_remediate }}"

# Windows Server 2022 Remediation
# Feature flag routing: use_external_stig_role controls whether to use the
# Red Hat CoP external role (via win_stig_wrapper) or the existing win2022_stig role

- name: Apply Windows 2022 remediation via external role
  when:
    - windows_version == '2022'
    - use_external_stig_role | default(false) | bool
    - controls_to_remediate | length > 0
  ansible.builtin.include_role:
    name: win_stig_wrapper
  vars:
    controls_to_remediate: "{{ controls_to_remediate }}"
    remediation_category: "{{ remediation_category }}"
    windows_version: "{{ windows_version }}"
    trigger_source: "{{ trigger_source | default('manual') }}"

# Existing Windows 2022 remediation (fallback when feature flag is disabled)
- name: Apply Windows 2022 CAT I remediation
  when:
    - windows_version == '2022'
    - not (use_external_stig_role | default(false) | bool)
    - remediation_category == 'CAT1'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2022_stig/tasks/scan_driven_remediation.yml"
  vars:
    failed_cat1_controls: "{{ controls_to_remediate }}"

- name: Apply Windows 2022 CAT II remediation (map-driven)
  when:
    - windows_version == '2022'
    - not (use_external_stig_role | default(false) | bool)
    - remediation_category == 'CAT2'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2022_stig/tasks/scan_driven_cat2_remediation.yml"
  vars:
    failed_cat2_controls: "{{ controls_to_remediate }}"

- name: Apply Windows 2022 CAT III remediation (map-driven)
  when:
    - windows_version == '2022'
    - not (use_external_stig_role | default(false) | bool)
    - remediation_category == 'CAT3'
    - controls_to_remediate | length > 0
  ansible.builtin.include_tasks:
    file: "{{ playbook_dir }}/../roles/win2022_stig/tasks/scan_driven_cat3_remediation.yml"
  vars:
    failed_cat3_controls: "{{ controls_to_remediate }}"

- name: Skip remediation - no controls to remediate
  when: controls_to_remediate | default([]) | length == 0
  ansible.builtin.debug:
    msg: "No controls to remediate. System may already be compliant."

- name: Log remediation completion
  ansible.builtin.set_fact:
    remediation_result:
      started: "{{ remediation_start_time }}"
      completed: "{{ ansible_date_time.iso8601 }}"
      os_version: "{{ windows_version }}"
      profile: "{{ compliance_profile }}"
      trigger: "{{ trigger_source | default('manual') }}"
      category: "{{ remediation_category }}"
      mode: "{{ remediation_mode }}"
      dry_run: "{{ dry_run | default(false) }}"
      controls_count: "{{ controls_to_remediate | default([]) | length }}"
      controls: "{{ controls_to_remediate | default([]) }}"
      # Include scan-driven results if available
      automatable_controls: "{{ automatable_controls | default([]) }}"
      manual_controls: "{{ manual_controls | default([]) }}"
      unknown_v_ids: "{{ unknown_v_ids | default([]) }}"
      registry_changed: "{{ registry_changed_count | default(0) }}"
      multi_registry_changed: "{{ multi_registry_changed_count | default(0) }}"
      security_policy_changed: "{{ security_policy_changed_count | default(0) }}"
      user_rights_changed: "{{ user_rights_changed_count | default(0) }}"
      winrm_in_manual: "{{ winrm_in_manual | default(false) }}"

# ============================================================================
# Push remediation metrics to Prometheus
# ============================================================================
- name: Build remediation metrics payload
  ansible.builtin.set_fact:
    remediation_metrics_payload: |
      # HELP compliance_remediations_total Total remediation operations
      # TYPE compliance_remediations_total counter
      compliance_remediations_total{vm_name="{{ inventory_hostname }}",namespace="{{ hostvars[inventory_hostname]['namespace'] | default('unknown') }}",trigger="{{ trigger_source | default('manual') }}",result="{{ 'success' if (automatable_controls | default([]) | length) > 0 else 'skipped' }}"} 1

      # HELP compliance_remediation_controls_attempted Number of controls attempted to remediate
      # TYPE compliance_remediation_controls_attempted gauge
      compliance_remediation_controls_attempted{vm_name="{{ inventory_hostname }}",namespace="{{ hostvars[inventory_hostname]['namespace'] | default('unknown') }}"} {{ automatable_controls | default([]) | length }}

      # HELP compliance_remediation_controls_manual Number of controls requiring manual remediation
      # TYPE compliance_remediation_controls_manual gauge
      compliance_remediation_controls_manual{vm_name="{{ inventory_hostname }}",namespace="{{ hostvars[inventory_hostname]['namespace'] | default('unknown') }}"} {{ manual_controls | default([]) | length }}

      # HELP compliance_remediation_last_timestamp Timestamp of last remediation
      # TYPE compliance_remediation_last_timestamp gauge
      compliance_remediation_last_timestamp{vm_name="{{ inventory_hostname }}",namespace="{{ hostvars[inventory_hostname]['namespace'] | default('unknown') }}"} {{ ansible_date_time.epoch }}
  when: not dry_run

- name: Push remediation metrics to Pushgateway
  when:
    - not dry_run
    - metrics_config.pushgateway_url | default('') | length > 0
  ansible.builtin.uri:
    url: "{{ metrics_config.pushgateway_url }}/metrics/job/compliance_remediation/instance/{{ inventory_hostname }}"
    method: POST
    body: "{{ remediation_metrics_payload }}"
    headers:
      Content-Type: text/plain
    status_code: [200, 202]
  delegate_to: localhost
  ignore_errors: true
