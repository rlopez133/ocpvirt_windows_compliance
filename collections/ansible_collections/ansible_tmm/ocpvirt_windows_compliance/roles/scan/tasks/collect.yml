---
# Scan Role - Collect Results
# Parses XCCDF results and calculates compliance score
# Also extracts failed control IDs for scan-driven remediation

- name: Check if XCCDF result file exists
  ansible.builtin.set_fact:
    has_xccdf_result: "{{ scc_scan_output.xccdf_result is defined and scc_scan_output.xccdf_result | length > 0 }}"

- name: Parse XCCDF and calculate score
  when: has_xccdf_result
  ansible.windows.win_shell: |
    $xccdfPath = "{{ scc_scan_output.xccdf_result }}"

    if (-not (Test-Path $xccdfPath)) {
        @{
            error = "XCCDF file not found: $xccdfPath"
            total = 0
            passed = 0
            failed = 0
            not_applicable = 0
            score = 0
            status = "error"
            failed_controls = @{ cat1 = @(); cat2 = @(); cat3 = @() }
        } | ConvertTo-Json -Compress -Depth 3
        exit 0
    }

    try {
        [xml]$xccdf = Get-Content $xccdfPath -Raw

        # Define namespace manager for XCCDF
        $nsManager = New-Object System.Xml.XmlNamespaceManager($xccdf.NameTable)

        # Try XCCDF 1.2 namespace first
        $ns = "http://checklists.nist.gov/xccdf/1.2"
        $nsManager.AddNamespace("xccdf", $ns)

        # Find rule-result elements
        $results = $xccdf.SelectNodes("//xccdf:rule-result", $nsManager)

        if ($results.Count -eq 0) {
            # Try XCCDF 1.1 namespace
            $ns = "http://checklists.nist.gov/xccdf/1.1"
            $nsManager = New-Object System.Xml.XmlNamespaceManager($xccdf.NameTable)
            $nsManager.AddNamespace("xccdf", $ns)
            $results = $xccdf.SelectNodes("//xccdf:rule-result", $nsManager)
        }

        if ($results.Count -eq 0) {
            # Try without namespace (some exports)
            $results = $xccdf.SelectNodes("//rule-result")
        }

        # Count results by status and collect failed control IDs
        $passed = 0
        $failed = 0
        $notApplicable = 0
        $notChecked = 0
        $cat1Failed = 0
        $cat2Failed = 0
        $cat3Failed = 0

        # Lists to hold failed control IDs by severity
        $cat1FailedIds = @()
        $cat2FailedIds = @()
        $cat3FailedIds = @()

        foreach ($result in $results) {
            $status = $result.result
            $ruleId = $result.idref
            $severity = $result.severity

            # Extract V-ID from rule ID (e.g., "xccdf_mil.disa.stig_rule_SV-205711r569188_rule" -> "V-205711")
            $vulnId = ""
            if ($ruleId -match "SV-(\d+)") {
                $vulnId = "V-$($Matches[1])"
            } elseif ($ruleId -match "(V-\d+)") {
                $vulnId = $Matches[1]
            }

            switch ($status) {
                "pass" { $passed++ }
                "fail" {
                    $failed++
                    # Categorize by severity and collect IDs
                    switch ($severity) {
                        "high" {
                            $cat1Failed++
                            if ($vulnId) { $cat1FailedIds += $vulnId }
                        }
                        "medium" {
                            $cat2Failed++
                            if ($vulnId) { $cat2FailedIds += $vulnId }
                        }
                        "low" {
                            $cat3Failed++
                            if ($vulnId) { $cat3FailedIds += $vulnId }
                        }
                        default {
                            # Try to detect from rule ID
                            if ($ruleId -match "CAT.?I[^I]|high") {
                                $cat1Failed++
                                if ($vulnId) { $cat1FailedIds += $vulnId }
                            }
                            elseif ($ruleId -match "CAT.?II|medium") {
                                $cat2Failed++
                                if ($vulnId) { $cat2FailedIds += $vulnId }
                            }
                            else {
                                $cat3Failed++
                                if ($vulnId) { $cat3FailedIds += $vulnId }
                            }
                        }
                    }
                }
                "notapplicable" { $notApplicable++ }
                { $_ -in "notchecked", "notselected", "informational" } { $notChecked++ }
            }
        }

        $total = $results.Count
        $applicable = $passed + $failed
        $score = if ($applicable -gt 0) { [math]::Round(($passed / $applicable) * 100, 2) } else { 0 }

        # Determine status
        $complianceStatus = "unknown"
        if ($cat1Failed -gt 0) {
            $complianceStatus = "critical"
        } elseif ($score -lt 80) {
            $complianceStatus = "warning"
        } elseif ($score -lt 95) {
            $complianceStatus = "info"
        } else {
            $complianceStatus = "compliant"
        }

        @{
            total = $total
            passed = $passed
            failed = $failed
            not_applicable = $notApplicable
            not_checked = $notChecked
            score = $score
            status = $complianceStatus
            cat1_failed = $cat1Failed
            cat2_failed = $cat2Failed
            cat3_failed = $cat3Failed
            failed_controls = @{
                cat1 = $cat1FailedIds
                cat2 = $cat2FailedIds
                cat3 = $cat3FailedIds
            }
        } | ConvertTo-Json -Compress -Depth 3
    } catch {
        @{
            error = $_.Exception.Message
            total = 0
            passed = 0
            failed = 0
            score = 0
            status = "error"
            failed_controls = @{ cat1 = @(); cat2 = @(); cat3 = @() }
        } | ConvertTo-Json -Compress -Depth 3
    }
  register: score_result

- name: Parse score result
  when: has_xccdf_result and score_result.stdout is defined
  ansible.builtin.set_fact:
    calculated_score: "{{ score_result.stdout | from_json }}"

- name: Set empty score if no results
  when: not has_xccdf_result or calculated_score is not defined
  ansible.builtin.set_fact:
    calculated_score:
      total: 0
      passed: 0
      failed: 0
      not_applicable: 0
      not_checked: 0
      score: 0
      status: "no_results"
      cat1_failed: 0
      cat2_failed: 0
      cat3_failed: 0
      failed_controls:
        cat1: []
        cat2: []
        cat3: []

- name: Build scan result object
  ansible.builtin.set_fact:
    scan_result:
      scan_id: "{{ scc_scan_output.scan_id }}"
      vm_name: "{{ inventory_hostname }}"
      namespace: "{{ hostvars[inventory_hostname]['namespace'] | default('unknown') }}"
      timestamp: "{{ scc_scan_output.completed }}"
      profile: "{{ compliance_profile }}"
      os_version: "{{ windows_version }}"
      duration_seconds: "{{ scc_scan_output.duration_seconds }}"
      score: "{{ calculated_score }}"
      status: "{{ calculated_score.status }}"
      failed_controls: "{{ calculated_score.failed_controls | default({'cat1': [], 'cat2': [], 'cat3': []}) }}"
      artifacts:
        xccdf_result: "{{ scc_scan_output.xccdf_result | default(None) }}"
        html_report: "{{ scc_scan_output.html_report | default(None) }}"

- name: Add to scan_results list
  ansible.builtin.set_fact:
    scan_results: "{{ scan_results | default([]) + [scan_result] }}"

- name: Display collected results
  ansible.builtin.debug:
    msg: |
      Results Collected
      - Total Controls: {{ scan_result.score.total | default(0) }}
      - Passed: {{ scan_result.score.passed | default(0) }}
      - Failed: {{ scan_result.score.failed | default(0) }}
      - CAT1 Failed: {{ scan_result.score.cat1_failed | default(0) }}
      - CAT2 Failed: {{ scan_result.score.cat2_failed | default(0) }}
      - CAT3 Failed: {{ scan_result.score.cat3_failed | default(0) }}
      - Score: {{ scan_result.score.score | default(0) }}%
      - Status: {{ scan_result.status }}
      - Failed CAT1 Controls: {{ scan_result.failed_controls.cat1 | join(', ') | default('None') }}
